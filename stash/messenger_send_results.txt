Case#1 
1. No.of threads 2, queue size 512.
2. add_job() uses MCAS
3. get_job() uses CAS_int no locking.
4. Single CPU shared multi-user environment.
5. Number of runs 2 select best performer.

static bool
add_job( job_ctrl *ctrl, job_item *item ) {
  job_item *rear_item;
  int rear;
  int tmp;

  if ( job_queue_full( ctrl ) ) {
    return 0;
  }
  while ( true ) {
    rear = ctrl->rear;
    tmp = ( rear + 1 ) % ITEM_ARRAY_SIZE;
    if ( rear != ctrl->rear ) {
      continue;
    }
    rear_item = &ctrl->item[ rear ];
    if ( MCAS( ( int * ) &ctrl->item[ rear ], ( int * ) rear_item,  ( int * ) item, sizeof( *item ) ) ) {
      CAS_int( &ctrl->rear, rear, tmp );
      return 1;
    }
  }
}


static void
get_job( job_ctrl *ctrl ) {
  job_item *item;
  struct timespec req;
  int front;
  int tmp;
  int rear;

  req.tv_sec = 0;
  req.tv_nsec = 1;
  while ( true ) {
    front = ctrl->front;
    rear = ctrl->rear;
    if ( front == rear ) {
      nanosleep( &req, NULL );
      continue;
    }
    front = ctrl->front;
    item = &ctrl->item[ front ];
    if ( item->opt.server_socket != -1 ) {
      tmp = ( front + 1 ) % ITEM_ARRAY_SIZE;
      if ( CAS_int( &ctrl->front, front, tmp ) ) {
        send( item->opt.server_socket, item->opt.buffer, item->opt.buffer_len, MSG_DONTWAIT );
      }
    }
  }
}

Results:
./trema run ./objects/examples/cbench_switch/cbench_switch -d
/home/nick/test_develop/objects/oflops/bin/cbench --switches 1 --loops 10 --delay 1000 --throughput
cbench: controller benchmarking tool
   running in mode 'throughput'
   connecting to controller at localhost:6633
   faking 1 switches :: 10 tests each; 1000 ms per test
   with 100000 unique source MACs per switch
   starting test with 1000 ms delay after features_reply
   ignoring first 1 "warmup" and last 0 "cooldown" loops
   debugging info is off
1   switches: fmods/sec:  30217   total = 29.924725 per ms
1   switches: fmods/sec:  30322   total = 30.309664 per ms
1   switches: fmods/sec:  29261   total = 29.196184 per ms
1   switches: fmods/sec:  28278   total = 28.276134 per ms
1   switches: fmods/sec:  28527   total = 28.319840 per ms
1   switches: fmods/sec:  28225   total = 28.205933 per ms
1   switches: fmods/sec:  27519   total = 27.357672 per ms
1   switches: fmods/sec:  28521   total = 28.296917 per ms
1   switches: fmods/sec:  28452   total = 28.295948 per ms
1   switches: fmods/sec:  28105   total = 27.874008 per ms
RESULT: 1 switches 9 tests min/max/avg/stdev = 27357.67/30309.66/28459.14/795.35 responses/s

grep -c "queue is full" *.log
cbench_switch.log:0
switch.0x1.log:0
switch_manager.log:0
Above indicates no queue full.



Case#2 
1. No.of threads 2, queue size 512.
2. add_job() uses CAS memcpy. Operation locked.
3. get_job() uses CAS_int no locking.
4. Single CPU shared multi-user environment.
5. Number of runs 2 select best performer.

static int
CAS( void *shared, const void *oldvalue, const void *newvalue, size_t len ) {
  int ret = 0;

  job_lock();
  if ( !memcmp( shared, oldvalue, len ) ) {
    memcpy( shared, newvalue, len );
    ret = 1;
  }
  job_unlock();
  return ret;
}

static bool
add_job( job_ctrl *ctrl, job_item *item ) {
  job_item *rear_item;
  int rear;
  int tmp;

  if ( job_queue_full( ctrl ) ) {
    return 0;
  }
  while ( true ) {
    rear = ctrl->rear;
    tmp = ( rear + 1 ) % ITEM_ARRAY_SIZE;
    if ( rear != ctrl->rear ) {
      continue;
    }
    rear_item = &ctrl->item[ rear ];
    if ( CAS( ( int * ) &ctrl->item[ rear ], ( int * ) rear_item,  ( int * ) item, sizeof( *item ) ) ) {
      CAS_int( &ctrl->rear, rear, tmp );
      return 1;
    }
  }
}

static void
get_job( job_ctrl *ctrl ) {
  job_item *item;
  struct timespec req;
  int front;
  int tmp;
  int rear;

  req.tv_sec = 0;
  req.tv_nsec = 1;
  while ( true ) {
    front = ctrl->front;
    rear = ctrl->rear;
    if ( front == rear ) {
      nanosleep( &req, NULL );
      continue;
    }
    front = ctrl->front;
    item = &ctrl->item[ front ];
    if ( item->opt.server_socket != -1 ) {
      tmp = ( front + 1 ) % ITEM_ARRAY_SIZE;
      if ( CAS_int( &ctrl->front, front, tmp ) ) {
        send( item->opt.server_socket, item->opt.buffer, item->opt.buffer_len, MSG_DONTWAIT );
      }
    }
  }
}

Results:
./trema run ./objects/examples/cbench_switch/cbench_switch -d
/home/nick/test_develop/objects/oflops/bin/cbench --switches 1 --loops 10 --delay 1000 --throughput
cbench: controller benchmarking tool
   running in mode 'throughput'
   connecting to controller at localhost:6633
   faking 1 switches :: 10 tests each; 1000 ms per test
   with 100000 unique source MACs per switch
   starting test with 1000 ms delay after features_reply
   ignoring first 1 "warmup" and last 0 "cooldown" loops
   debugging info is off
1   switches: fmods/sec:  29685   total = 29.423513 per ms
1   switches: fmods/sec:  28573   total = 28.445422 per ms
1   switches: fmods/sec:  28083   total = 27.728135 per ms
1   switches: fmods/sec:  29113   total = 28.802651 per ms
1   switches: fmods/sec:  28955   total = 28.625718 per ms
1   switches: fmods/sec:  28644   total = 28.640076 per ms
1   switches: fmods/sec:  28682   total = 28.469278 per ms
1   switches: fmods/sec:  28344   total = 28.298496 per ms
1   switches: fmods/sec:  28202   total = 28.191315 per ms
1   switches: fmods/sec:  28174   total = 28.006911 per ms
RESULT: 1 switches 9 tests min/max/avg/stdev = 27728.14/28802.65/28356.44/319.77 responses/s

Case#3 
1. No.of threads 2, queue size 512.
2. add_job() uses MCAS.
3. partition queue size into two halves.
4. Single CPU shared multi-user environment.
5. Number of runs 2 select best performer.


static bool
add_job( job_ctrl *ctrl, job_item *item ) {
  job_item *rear_item;
  int rear;
  int tmp;

  if ( job_queue_full( ctrl ) ) {
    return 0;
  }
  while ( true ) {
    rear = ctrl->rear;
    tmp = ( rear + 1 ) % ITEM_ARRAY_SIZE;
    if ( rear != ctrl->rear ) {
      continue;
    }
    rear_item = &ctrl->item[ rear ];
    if ( MCAS( ( int * ) &ctrl->item[ rear ], ( int * ) rear_item,  ( int * ) item, sizeof( *item ) ) ) {
      CAS_int( &ctrl->rear, rear, tmp );
      return 1;
    }
  }
}


void
*exec_partition( void *data ) {
  job_ctrl *ctrl = data;
  int ret = 1;
  job_item *item;
  struct timespec req;
  int front;
  int tmp;
  int rear;
  int thread_idx = 1;


  if ( ctrl->tid[ 1 ] == self() ) {
    thread_idx = 2;
  }
  int min = ( thread_idx - 1 ) * 256;
  int max = thread_idx * 256;

  req.tv_sec = 0;
  while ( true ) {
    front = ctrl->front;
    rear = ctrl->rear;
    if ( front == rear ) {
      req.tv_nsec = 1;
      nanosleep( &req, NULL );
      continue;
    }
    front = ctrl->front;
    if ( front >= min && front < max ) {
      item = &ctrl->item[ front ];
      tmp = ( front + 1 ) % ITEM_ARRAY_SIZE;
      ctrl->front = tmp;
      send( item->opt.server_socket, item->opt.buffer, item->opt.buffer_len, MSG_DONTWAIT );
    }
    else {
      req.tv_nsec = 10;
      nanosleep( &req, NULL );
    }
  }
  return ( void * ) ( intptr_t ) ret;
}

Result:
./trema run ./objects/examples/cbench_switch/cbench_switch -d
/home/nick/test_develop/objects/oflops/bin/cbench --switches 1 --loops 10 --delay 1000 --throughput
cbench: controller benchmarking tool
   running in mode 'throughput'
   connecting to controller at localhost:6633
   faking 1 switches :: 10 tests each; 1000 ms per test
   with 100000 unique source MACs per switch
   starting test with 1000 ms delay after features_reply
   ignoring first 1 "warmup" and last 0 "cooldown" loops
   debugging info is off
1   switches: fmods/sec:  28647   total = 28.320605 per ms
1   switches: fmods/sec:  28443   total = 28.355721 per ms
1   switches: fmods/sec:  29291   total = 29.233965 per ms
1   switches: fmods/sec:  29510   total = 29.126894 per ms
1   switches: fmods/sec:  28594   total = 28.214654 per ms
1   switches: fmods/sec:  28571   total = 28.217436 per ms
1   switches: fmods/sec:  28300   total = 28.148365 per ms
1   switches: fmods/sec:  27942   total = 27.760392 per ms
1   switches: fmods/sec:  27631   total = 27.625005 per ms
1   switches: fmods/sec:  27245   total = 27.031237 per ms
RESULT: 1 switches 9 tests min/max/avg/stdev = 27031.24/29233.96/28190.41/653.60 responses/s

Case#4
1. No.of threads 2, queue size 512.
2. add_job() uses CAS memcpy. Operation locked.
3. partition queue size into two halves.
4. Single CPU shared multi-user environment.
5. Number of runs 2 select best performer.

static bool
add_job( job_ctrl *ctrl, job_item *item ) {
  job_item *rear_item;
  int rear;
  int tmp;

  if ( job_queue_full( ctrl ) ) {
    return 0;
  }
  while ( true ) {
    rear = ctrl->rear;
    tmp = ( rear + 1 ) % ITEM_ARRAY_SIZE;
    if ( rear != ctrl->rear ) {
      continue;
    }
    rear_item = &ctrl->item[ rear ];
    if ( CAS( ( int * ) &ctrl->item[ rear ], ( int * ) rear_item,  ( int * ) item, sizeof( *item ) ) ) {
      CAS_int( &ctrl->rear, rear, tmp );
      return 1;
    }
  }
}


void
*exec_partition( void *data ) {
  job_ctrl *ctrl = data;
  int ret = 1;
  job_item *item;
  struct timespec req;
  int front;
  int tmp;
  int rear;
  int thread_idx = 1;


  if ( ctrl->tid[ 1 ] == self() ) {
    thread_idx = 2;
  }
  int min = ( thread_idx - 1 ) * 256;
  int max = thread_idx * 256;

  req.tv_sec = 0;
  while ( true ) {
    front = ctrl->front;
    rear = ctrl->rear;
    if ( front == rear ) {
      req.tv_nsec = 1;
      nanosleep( &req, NULL );
      continue;
    }
    front = ctrl->front;
    if ( front >= min && front < max ) {
      item = &ctrl->item[ front ];
      tmp = ( front + 1 ) % ITEM_ARRAY_SIZE;
      ctrl->front = tmp;
      send( item->opt.server_socket, item->opt.buffer, item->opt.buffer_len, MSG_DONTWAIT );
    }
    else {
      req.tv_nsec = 10;
      nanosleep( &req, NULL );
    }
  }
  return ( void * ) ( intptr_t ) ret;
}

Result:
./trema run ./objects/examples/cbench_switch/cbench_switch -d
/home/nick/test_develop/objects/oflops/bin/cbench --switches 1 --loops 10 --delay 1000 --throughput
cbench: controller benchmarking tool
   running in mode 'throughput'
   connecting to controller at localhost:6633
   faking 1 switches :: 10 tests each; 1000 ms per test
   with 100000 unique source MACs per switch
   starting test with 1000 ms delay after features_reply
   ignoring first 1 "warmup" and last 0 "cooldown" loops
   debugging info is off
1   switches: fmods/sec:  30175   total = 29.969708 per ms
1   switches: fmods/sec:  30234   total = 29.969697 per ms
1   switches: fmods/sec:  29279   total = 29.228785 per ms
1   switches: fmods/sec:  28245   total = 28.145029 per ms
1   switches: fmods/sec:  28829   total = 28.514175 per ms
1   switches: fmods/sec:  29193   total = 28.860955 per ms
1   switches: fmods/sec:  28563   total = 28.558374 per ms
1   switches: fmods/sec:  28240   total = 27.940340 per ms
1   switches: fmods/sec:  28216   total = 28.046292 per ms
1   switches: fmods/sec:  27516   total = 27.474760 per ms
RESULT: 1 switches 9 tests min/max/avg/stdev = 27474.76/29969.70/28526.49/708.28 responses/s

http://chart.apis.google.com/chart?chxl=1:|MCAS%2FCAS_int|CAS%2FCAS_int|partition%2FMCAS|partition%2FCAS&chxp=1,50,110,170,220&chxr=0,25005,35005|1,10,220&chxs=0,676767,11.5,-0.5,lt,676767|1,676767,11.5,1,l,676767&chxt=y,x&chbh=70,5&chs=800x227&cht=bvg&chco=A2C180,FF9900,FF5100,0062FF&chds=25000,35000,25000,35000,25005,35005,25005,35010&chd=t:28459|28356|28190|28526&chm=N,000000,0,-1,10|N,000000,1,-0.5,9|N,000000,2,-1,10,-1|N,000000,3,-1.5,10&chtt=Messenger+send+performance&chts=676767,13

<img src="http://chart.apis.google.com/chart?chxl=1:|MCAS%2FCAS_int|CAS%2FCAS_int|partition%2FMCAS|partition%2FCAS&chxp=1,50,110,170,220&chxr=0,25005,35005|1,10,220&chxs=0,676767,11.5,-0.5,lt,676767|1,676767,11.5,1,l,676767&chxt=y,x&chbh=70,5&chs=800x227&cht=bvg&chco=A2C180,FF9900,FF5100,0062FF&chds=25000,35000,25000,35000,25005,35005,25005,35010&chd=t:28459|28356|28190|28526&chm=N,000000,0,-1,10|N,000000,1,-0.5,9|N,000000,2,-1,10,-1|N,000000,3,-1.5,10&chtt=Messenger+send+performance&chts=676767,13" width="800" height="227" alt="Messenger send performance" />
http://chart.apis.google.com/chart
   ?chxl=1:|MCAS%2FCAS_int|CAS%2FCAS_int|partition%2FMCAS|partition%2FCAS
   &chxp=1,50,110,170,220
   &chxr=0,25005,35005|1,10,220
   &chxs=0,676767,11.5,-0.5,lt,676767|1,676767,11.5,1,l,676767
   &chxt=y,x
   &chbh=70
   &chs=800x227
   &cht=bvg
   &chco=A2C180,FF9900,FF5100,0062FF
   &chds=25000,35000,25000,35000,25005,35005,25005,35010
   &chd=t:28459|28356|28190|28526
   &chm=N,000000,0,-1,10|N,000000,1,-0.5,9|N,000000,2,-1,10,-1|N,000000,3,-1.5,10
   &chtt=Messenger+send+performance
   &chts=676767,13
