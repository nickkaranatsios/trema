#
# Author: Yasuhito Takamiya <yasuhito@gmail.com>
#
# Copyright (C) 2008-2012 NEC Corporation
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License, version 2, as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#


$LOAD_PATH.unshift File.expand_path( File.join File.dirname( __FILE__ ), "ruby" )
$LOAD_PATH.unshift File.expand_path( File.join File.dirname( __FILE__ ), "vendor", "ruby-ifconfig-1.2", "lib" )


require "rake/clean"


require "trema/executables"
require "trema/path"
require "trema/dsl/parser"


puts self.inspect
################################################################################
# Main tasks
################################################################################


desc "Build trema."
task :default => [
  :libtrema,
  :rubylib,
  :switch_manager,
  :switch,
  :packetin_filter,
  :tremashark,
  :packet_capture,
  :syslog_relay,
  :stdin_relay,
  :vendor,
  :examples,
  :apps
]


task :examples => [
  "examples:cbench_switch",
  "examples:dumper",
  "examples:hello_trema",
  "examples:learning_switch",
  "examples:list_switches",
  "examples:multi_learning_switch",
  "examples:openflow_message",
  "examples:packet_in",
  "examples:repeater_hub",
  "examples:packetin_filter_config",
  "examples:switch_info",
  "examples:switch_monitor",
  "examples:traffic_monitor",
]


task :apps => [
  :topology,
  :broadcast_helper,
  :flow_dumper,
  :flow_manager,
  :load_balance_switch,
  :packetin_dispatcher,
  :path_manager,
  :routing_switch,
  :show_description,
  :simple_load_balancer,
  :sliceable_switch,
  :topology_client,
  :path_resolver_client,
  :authenticator
]


desc "Cleanup generated files."

CLEAN.include Trema.objects
CLEAN.include File.join( Trema.home, "objects/unittests" )
CLEAN.include File.join( Trema.home, "unittests/objects" )
CLEAN.include Trema::DSL::Context::PATH


desc "Cleanup everything."
task :distclean => :clean


################################################################################
# Helpers
################################################################################


def objects path
  File.join Trema.objects, path
end


def cbench_command
  File.join Trema.objects, "oflops/bin/cbench"
end


def trema_directory dir
  mkdir_p dir unless File.exists? dir
end


################################################################################
# !!!!!! DO NOT MODIFY !!!!!!
################################################################################
CFLAGS = [ 
  '-g',
  '-std=gnu99',
  '-D_GNU_SOURCE',
  '-fno-strict-aliasing',
  '-Werror',
  '-Wall',
  '-Wextra',
  '-Wformat=2',
  '-Wcast-qual',
  '-Wcast-align',
  '-Wwrite-strings',
  '-Wconversion',
  '-Wfloat-equal',
  '-Wpointer-arith'
].join( ' ' )


################################################################################
# Tasks libtrema and coverage:libtrema
# The directory Trema.lib didn't work that's why the following
################################################################################
trema_directory Trema.lib
trema_directory "#{ Trema.home }/objects/unittests"

libtrema = File.join( Trema.lib, "libtrema.a" )
libtrema_gcov = File.join( "#{ Trema.home }/objects/unittests", "libtrema.a" )

libtrema_src = FileList[ "#{ Trema.include }/*.c" ]
libtrema_objs = libtrema_gcov_objs = []
libtrema_src.each do | fn |
  if fn =~ /#{ Trema.include }\/(.*)\.c$/
    libtrema_objs << "#{ Trema.lib }/#{ $1 }.o"
    libtrema_gcov_objs << "#{ Trema.home }/objects/unittests/#{ $1 }.o"
  end
end
# one line substitution did not work that's why I used the above code
# libtrema_objs = libtrema_src.sub( /#{ Trema.include }\/(.*)\.c$/ ) { | str | "#{ Trema.lib }\/#{ $1 }\.o" }


# Trema.lib = "objects/lib"
# Trema.include = "src/lib"
rule /#{ Trema.lib }\/.*.o$/ => lambda { | fn | fn.sub( /#{ Trema.lib }\/(.*).o$/ ) { | str | "#{ Trema.include }/#{ $1 }.c" }  } do | t |
  sh "gcc -I#{ objects "openflow" } #{ CFLAGS } -fPIC -c -o #{ t.name } #{ t.source }"
end


rule /#{ Trema.home }\/objects\/unittests\/.*.o$/ => lambda { | fn | fn.sub( /#{ Trema.home }\/objects\/unittests\/(.*).o$/ ) { | str | "#{ Trema.include }/#{ $1 }.c" } } do | t |
  sh "gcc --coverage -I#{ objects "openflow" } #{ CFLAGS } -fPIC -c -o #{ t.name } #{ t.source }"
end


desc "Build trema library."
task :libtrema => [ "vendor:openflow", libtrema ]
file libtrema => libtrema_objs do | t |
  sh "ar -cq #{ t.name } #{ libtrema_objs.join( ' ' ) }"
  sh "ranlib #{ t.name }"
end


task :clean => "libtrema:clean"
task :distclean => "libtrema:distclean"


task "libtrema:clean" do
  cd Trema.lib do
    rm_f FileList[ "*.o" ]
  end
end


task "libtrema:distclean" do
  rm_f libtrema
end


desc "Build trema library (coverage)."
task "coverage:libtrema" => libtrema_gcov
file libtrema_gcov => libtrema_gcov_objs do | t |
  sh "ar -cq #{ t.name } #{ libtrema_gcov_objs.join( ' ' ) }"
  sh "ranlib #{ t.name }"
end


task :clean => "coverage:libtrema:clean"
task :distclean => "coverage:libtrema:distclean"


task "coverage:libtrema:clean" => "libtrema:clean"
task "coverage:libtrema:distclean" do
  rm_f libtrema_gcov
end


################################################################################
# Task rubylib
################################################################################
desc "Build ruby library."
task :rubylib => "ruby/trema.so"
file "ruby/trema.so" => FileList[ "ruby/trema/*.c", "ruby/trema/*.h", libtrema ] do
  cd "ruby" do
    sh "ruby extconf.rb --with-trema-include=#{ Trema.include } --with-trema-lib=#{ Trema.lib } --with-openflow-include=#{ Trema.openflow }"
    sh "make"
  end
end


task :clean => "rubylib:clean"
task :distclean => "rubylib:distclean"


task "rubylib:clean" do
  cd "ruby" do
    sh "make clean" rescue nil
  end
end


task "rubylib:distclean" do
  rm_f "ruby/trema.so"
  rm_f "ruby/Makefile"
end


################################################################################
# Task switch_manager
################################################################################
desc "Build switch manager"
task :switch_manager => Trema::Executables.switch_manager
switch_manager_objects_dir = objects( "switch_manager" )


# Trema::Executables.switch_manager => objects/switch_manager/switch_manager
#
rule /#{ switch_manager_objects_dir }\/.*.o$/ => lambda { | fn | fn.sub( /#{ switch_manager_objects_dir }\/(.*).o$/ ) { | str | "src/switch_manager/#{ $1 }.c" }  } do | t |
  sh "gcc -I#{ Trema.include } -I#{ Trema.openflow } #{ CFLAGS } -c -o #{ t.name } #{ t.source }"
end


trema_directory switch_manager_objects_dir
switch_manager_objects = [
  "dpid_table.o",
  "switch_manager.o",
  "secure_channel_listener.o"
].collect do | each |
  File.join switch_manager_objects_dir, each
end


file Trema::Executables.switch_manager => switch_manager_objects + [ libtrema ] do | t |
  sh "gcc -L#{ Trema.lib } -o #{ t.name } #{ switch_manager_objects.join( ' ' ) } -ltrema -lsqlite3 -ldl -lrt -lpthread"
end


task :clean => "switch_manager:clean"
task :distclean => "switch_manager:distclean"


task "switch_manager:clean" do
  cd switch_manager_objects_dir do
    rm_f switch_manager_objects
  end
end


task "switch_manager:distclean" do
  rm_f Trema::Executables.switch_manager
end


################################################################################
# Task switch
################################################################################
desc "Build switch"
task :switch => Trema::Executables.switch


switch_objects = [
  "cookie_table.o",
  "ofpmsg_recv.o",
  "ofpmsg_send.o",
  "secure_channel_receiver.o",
  "secure_channel_sender.o",
  "service_interface.o",
  "switch.o",
  "xid_table.o",
].collect do | each |
  File.join switch_manager_objects_dir, each
end


#
# Trema::Executables.switch => objects/switch_manager/switch
#
file Trema::Executables.switch => switch_objects + [ libtrema ] do | t |
  sh "gcc -L#{ Trema.lib } -o #{ t.name } #{ switch_objects.join( ' ' ) } -ltrema -lsqlite3 -ldl -lrt -lpthread"
end


task :clean => "switch:clean"
task :distclean => "switch:distclean"


task "switch:clean" do
  cd switch_manager_objects_dir do
    rm_f switch_objects
  end
end


task "switch:distclean" do
  rm_f Trema::Executables.switch
end


################################################################################
# Task packetin_filter
################################################################################
desc "Build packetin filter."
# Trema::Executables.packetin_filter => objects/packetin_filter/packetin_filter
task :packetin_filter => Trema::Executables.packetin_filter
packetin_filter_objects_dir = objects( "packetin_filter" )


packetin_filter_src = FileList[ "src/packetin_filter/*.c" ]
trema_directory packetin_filter_objects_dir


packetin_filter_objs = []
packetin_filter_src.each do | each |
  if each =~ /src\/packetin_filter\/(.*)\.c$/
    packetin_filter_objs << "#{ packetin_filter_objects_dir }/#{ $1 }\.o"
  end
end


rule /#{ packetin_filter_objects_dir }\/.*.o$/ => lambda { | fn | fn.sub( /#{ packetin_filter_objects_dir }\/(.*).o$/ ) { | str | "src/packetin_filter/#{ $1 }.c" } } do | t |
  sh "gcc -I#{ Trema.include } -I#{ Trema.openflow } #{ CFLAGS } -c -o #{ t.name } #{ t.source }"
end


file Trema::Executables.packetin_filter => packetin_filter_objs + [ libtrema ] do | t |
  sh "gcc -L#{ Trema.lib } -o #{ t.name } #{ packetin_filter_objs.join( ' ' ) } -ltrema -lpthread -lsqlite3 -ldl -lrt"
end


task :clean => "packetin_filter:clean"
task :distclean => "packetin_filter:distclean"


task "packetin_filter:clean" do
  cd packetin_filter_objects_dir do
    rm_f packetin_filter_objs
  end
end


task "packetin_filter:distclean" do
  begin
    rm_f Trema::Executables.packetin_filter
  rescue
  end
end


################################################################################
# Task tremashark
################################################################################
desc "Build tremashark."
# Trema::Executables => objects/tremashark/tremashark
task :tremashark => Trema::Executables.tremashark
tremashark_objects_dir = objects( "tremashark" )

tremashark_src = FileList[ "src/tremashark/*.c" ]
trema_directory tremashark_objects_dir


tremashark_objs = []
tremashark_src.each do | each |
  if each =~ /src\/tremashark\/(.*)\.c$/
    tremashark_objs << "#{ tremashark_objects_dir }/#{ $1 }\.o"
  end
end


rule /#{ tremashark_objects_dir }\/.*.o$/ => lambda { | fn | fn.sub( /#{ tremashark_objects_dir }\/(.*).o$/ ) { | str | "src/tremashark/#{ $1 }.c" } } do | t |
  sh "gcc -I#{ Trema.include } -I#{ Trema.openflow } #{ CFLAGS } -c -o #{ t.name } #{ t.source }"
end


tremashark_objects = [
  "pcap_queue.o",
  "queue.o",
  "tremashark.o",
].collect do | each |
  File.join tremashark_objects_dir, each
end


file Trema::Executables.tremashark => tremashark_objects + [ libtrema ] do | t |
  sh "gcc -L#{ Trema.lib } -o #{ t.name } #{ tremashark_objects.join( ' ' ) } -ltrema -lsqlite3 -ldl -lrt -lpcap -lpthread"
end


task :clean => "tremashark:clean"
task :distclean => "tremashark:distclean"


task "tremashark:clean" do
  cd tremashark_objects_dir do
    rm_f tremashark_objects
  end
end


task "tremashark:distclean" do
  rm_f Trema::Executables.tremashark
end


################################################################################
# Task packet_capture
################################################################################
desc "Build packet_capture."
# Trema::Executables.packet_capture => objects/tremashark/packet_capture
task :packet_capture => Trema::Executables.packet_capture


packet_capture_objects = [
  "packet_capture.o",
  "queue.o",
].collect do | each |
  File.join tremashark_objects_dir, each
end


file Trema::Executables.packet_capture => packet_capture_objects + [ libtrema ] do | t |
  sh "gcc -L#{ Trema.lib } -o #{ t.name } #{ packet_capture_objects.join( ' ' ) } -ltrema -lsqlite3 -ldl -lrt -lpcap -lpthread"
end


task :clean => "packet_capture:clean"
task :distclean => "packet_capture:distclean"


task "packet_capture:clean" do
  cd tremashark_objects_dir do
    rm_f packet_capture_objects
  end
end


task "packet_capture:distclean" do
  rm_f Trema::Executables.packet_capture
end


################################################################################
# Task syslog_relay 
################################################################################
desc "Build syslog_relay."
# Trema::Executables.syslog_relay => objects/tremashark/syslog_relay
task :syslog_relay => Trema::Executables.syslog_relay


syslog_relay_objects = [
  "syslog_relay.o",
].collect do | each |
  File.join tremashark_objects_dir, each
end


file Trema::Executables.syslog_relay => syslog_relay_objects + [ libtrema ] do | t |
  sh "gcc -L#{ Trema.lib } -o #{ t.name } #{ syslog_relay_objects.join( ' ' ) } -ltrema -lsqlite3 -ldl -lrt -lpcap -lpthread"
end


task :clean => "syslog_relay:clean"
task :distclean => "syslog_relay:distclean"


task "syslog_relay:clean" do
  cd tremashark_objects_dir do
    rm_f syslog_relay_objects
  end
end


task "syslog_relay:distclean" do
  rm_f Trema::Executables.syslog_relay
end


################################################################################
# Task stdin_relay
################################################################################
desc "Build stdin_relay."
# Trema::Executables.stdin_relay => objects/tremashark/stdin_relay
task :stdin_relay => Trema::Executables.stdin_relay


stdin_relay_objects = [
  "stdin_relay.o",
].collect do | each |
  File.join tremashark_objects_dir, each
end


file Trema::Executables.stdin_relay => stdin_relay_objects + [ libtrema ] do | t |
  sh "gcc -L#{ Trema.lib } -o #{ t.name } #{ stdin_relay_objects.join( ' ' ) } -ltrema -lsqlite3 -ldl -lrt -lpcap -lpthread"
end


task :clean => "stdin_relay:clean"
task :distclean => "stdin_relay:distclean"


task "stdin_relay:clean" do
  cd tremashark_objects_dir do
    rm_f stdin_relay_objects
  end
end


task "stdin_relay:distclean" do
  rm_f Trema::Executables.stdin_relay
end


################################################################################
# Task examples:openflow_message
################################################################################
openflow_messages = [
  "echo_reply",
  "echo_request",
  "features_request",
  "hello",
  "set_config",
]


openflow_message_source_dir = "src/examples/openflow_message"
openflow_message_objects_dir = objects( "examples/openflow_message" )

trema_directory openflow_message_objects_dir
rule /#{ openflow_message_objects_dir }\/.*.o$/ => lambda { | fn | fn.sub( /#{ openflow_message_objects_dir }\/(.*).o$/ ) { | str | "#{ openflow_message_source_dir }/#{ $1 }.c" } } do | t |
  sh "gcc -I#{ Trema.include } -I#{ Trema.openflow } #{ CFLAGS } -c -o #{ t.name } #{ t.source }"
end


openflow_messages.each do | each |
  object = File.join( openflow_message_objects_dir, "#{ each }.o" )
  target = File.join( openflow_message_objects_dir, each )
  task "examples:openflow_message" => target
  file target => [ object, libtrema ] do | t |
    sh "gcc -L#{ Trema.lib } -o #{ t.name } #{ object } -ltrema -lsqlite3 -ldl -lrt -lpthread"
  end
end


task :clean => "examples:openflow_message:clean"
task :distclean => "examples:openflow_message:clean"


task "examples:openflow_message:clean" do
  cd openflow_message_objects_dir do
    rm_f FileList[ "*.o" ]
  end
end


task "examples:openflow_message:distclean" do
  begin
    cd openflow_message_objects_dir do
      rm_f openflow_messages
    end
  rescue
  end
end


################################################################################
# Task examples:packetin_filter_config
################################################################################
packetin_filter_config = [
  "add_filter",
  "delete_filter",
  "delete_filter_strict",
  "dump_filter",
  "dump_filter_strict",
]


packetin_filter_config_source_dir = "src/examples/packetin_filter_config"
packetin_filter_config_objects_dir = objects( "examples/packetin_filter_config" )


trema_directory packetin_filter_config_objects_dir
rule /#{ packetin_filter_config_objects_dir }\/.*.o$/ => lambda { | fn | fn.sub( /#{ packetin_filter_config_objects_dir }\/(.*).o$/ ) { | str | "#{ packetin_filter_config_source_dir }/#{ $1 }.c" } } do | t |
  sh "gcc -I#{ Trema.include } -I#{ Trema.openflow } #{ CFLAGS } -c -o #{ t.name } #{ t.source }"
end


packetin_filter_config_utils_o = File.join( packetin_filter_config_objects_dir, "utils.o" )
packetin_filter_config.each do | each |
  target = File.join( packetin_filter_config_objects_dir, each )
  object = File.join( packetin_filter_config_objects_dir, "#{ each }.o" )
  task "examples:packetin_filter_config" => target
  file target => [ object, packetin_filter_config_utils_o, libtrema ] do | t |
    sh "gcc -L#{ Trema.lib } -o #{ t.name } #{ object } #{ packetin_filter_config_utils_o } -ltrema -lsqlite3 -ldl -lrt -lpthread"
  end
end


task :clean => "examples:packetin_filter_config:clean"
task :distclean => "examples:packetin_filter_config:distclean"


task "examples:packetin_filter_config:clean" do
  cd packetin_filter_config_objects_dir do
    rm_f FileList[ "*.o" ]
  end
end


task "examples:packetin_filter_config:distclean" do
  begin
    cd packetin_filter_config_objects_dir do
      rm_f packetin_filter_config
    end
  rescue
  end
end


################################################################################
# Task examples:standalone_examples
################################################################################
standalone_examples = [
  "cbench_switch",
  "dumper",
  "hello_trema",
  "learning_switch",
  "list_switches",
  "multi_learning_switch",
  "packet_in",
  "repeater_hub",
  "switch_info",
  "switch_monitor",
  "traffic_monitor",
]

standalone_examples.each do | each |
  objects_dir = objects( "examples/#{ each }" )
  target = objects( "examples/#{ each }/#{ each }" )


  trema_directory objects_dir
  rule /#{ objects_dir }\/.*.o$/ => lambda { | fn | fn.sub( /#{ objects_dir }\/(.*).o$/ ) { | str | "src/examples/#{ each }/#{ $1 }.c" } } do | t |
    sh "gcc -I#{ Trema.include } -I#{ Trema.openflow } #{ CFLAGS } -c -o #{ t.name } #{ t.source }"
  end


  src = FileList[ "src/examples/#{ each }/*.c" ]
  objects = []
  src.each do | fn |
    if fn =~ /src\/examples\/#{ each }\/(.*).c$/
      objects << "#{ objects_dir }/#{ $1 }.o"
    end
  end


  desc "Build #{ each } example."
  task "examples:#{ each }" => target
  file target => objects + [ libtrema ] do | t |
    sh "gcc -L#{ Trema.lib } -o #{ t.name } #{ objects.join( ' ') } -ltrema -lsqlite3 -ldl -lrt -lpthread"
  end
end


task :clean => [ "examples:clean" ]
task :distclean => "examples:distclean"


task "examples:clean" => [ "examples:openflow_message:clean", "examples:packetin_filter_config:clean" ] do
  standalone_examples.each do | each |
    cd objects( "examples/#{ each }" ) do
      rm_f FileList[ "*.o" ]
    end
  end
end


task "examples:distclean" => [ "examples:openflow_message:distclean", "examples:packetin_filter_config:distclean" ] do
  standalone_examples.each do | each |
    target = objects( "examples/#{ each }/#{ each }" )
    rm_f target
  end
end


################################################################################
# Task vendor:oflops 
################################################################################
task "vendor:oflops" => cbench_command
file cbench_command => Trema.openflow_h do
  sh "tar -xzf #{ Trema.vendor_oflops }.tar.gz -C #{ Trema.vendor }"
  cd Trema.vendor_oflops do
    sh "./configure --prefix=#{ Trema.oflops } --with-openflow-src-dir=#{ Trema.vendor_openflow }"
    sh "make install"
  end
end


task :clean => "vendor:oflops:clean"
task :distclean => "vendor:oflops:distclean"


task "vendor:oflops:clean" do
  begin
    rm_f cbench_command
    cd Trema.vendor_oflops do
      sh "make clean"
    end
  rescue
  end
end


task "vendor:oflops:distclean" do
  rm_f cbench_command
  rm_rf Trema.vendor_oflops
end


################################################################################
# Task vendor:openvswitch
################################################################################
task "vendor:openvswitch" => Trema::Executables.ovs_openflowd
file Trema::Executables.ovs_openflowd do
  sh "tar -xzf #{ Trema.vendor_openvswitch }.tar.gz -C #{ Trema.vendor }"
  cd Trema.vendor_openvswitch do
    sh "./configure --prefix=#{ Trema.openvswitch } --with-rundir=#{ Trema.sock }"
    sh "make install"
    sh "cp ./tests/test-openflowd #{ Trema::Executables.ovs_openflowd }"
  end
end


task :clean => "vendor:openvswitch:clean"
task :distclean => "vendor:openvswitch:distclean"


task "vendor:openvswitch:clean" do
  rm_f Trema::Executables.ovs_openflowd
  begin
    cd Trema.vendor_openvswitch do
      sh "make clean"
    end
  rescue
  end
end


task "vendor:openvswitch:distclean" do
  rm_rf Trema.vendor_openvswitch
end


################################################################################
# Task vendor:phost
################################################################################
# Trema::Executables.phost => "objects/phost/phost" 
# Trema::Executables.cli => "objects/phost/cli"
task "vendor:phost" => [ Trema::Executables.phost, Trema::Executables.cli ]


def phost_src
  File.join Trema.vendor_phost, "src"
end


file Trema::Executables.phost do
  cd phost_src do
    sh "make"
  end
  trema_directory File.dirname( Trema::Executables.phost )
  install File.join( phost_src, "phost" ), Trema::Executables.phost, :mode => 0755
end


file Trema::Executables.cli do
  cd phost_src do
    sh "make"
  end
  trema_directory File.dirname( Trema::Executables.cli )
  install File.join( phost_src, "cli" ), Trema::Executables.cli, :mode => 0755
end


task :clean => "vendor:phost:clean"
task :distclean => "vendor:phost:distclean"


task "vendor:phost:clean" do
  cd phost_src do
    sh "make clean"
  end
  rm_f [ Trema::Executables.phost, Trema::Executables.cli ]
end


task "vendor:phost:distclean" do
  rm_f [ Trema::Executables.phost, Trema::Executables.cli ]
end


################################################################################
# Task vendor:cmockery
################################################################################
# Trema.libcmockery_a => objects/cmockery/lib/libcmockery.a
task "vendor:cmockery" => Trema.libcmockery_a
file Trema.libcmockery_a do
  sh "tar -xzf #{ Trema.vendor_cmockery }.tar.gz -C #{ Trema.vendor }"
  cd Trema::vendor_cmockery do
    sh "./configure --prefix=#{ Trema.cmockery }"
    sh "make install"
  end
end


task :clean => "vendor:cmockery:clean"
task :distclean => "vendor:cmockery:distclean"


task "vendor:cmockery:clean" do
  rm_f Trema.libcmockery_a
  cd Trema::vendor_cmockery do
    sh "make clean"
  end
end


task "vendor:cmockery:distclean" do
  rm_f Trema.libcmockery_a
end
################################################################################
# Run cbench benchmarks.
################################################################################


################################################################################
# Task cbench defaults to cbench:c, cbench:ruby, cbench:profile
################################################################################
def cbench_command
  File.join Trema.objects, "oflops/bin/cbench"
end


def cbench_latency_mode_options
  "--switches 1 --loops 10 --delay 1000"
end


def cbench_throughput_mode_options
  cbench_latency_mode_options + " --throughput"
end


def cbench controller, options
  begin
    sh "#{ controller }"
    sh "#{ cbench_command } #{ options }"
  ensure
    sh "./trema killall"
  end
end


def cbench_c_controller
  "./trema run ./objects/examples/cbench_switch/cbench_switch -d"
end


def cbench_ruby_controller
  "./trema run src/examples/cbench_switch/cbench-switch.rb -d"
end


def run_cbench controller
  cbench controller, cbench_latency_mode_options
  cbench controller, cbench_throughput_mode_options
end


CLEAN.include FileList[ "callgrind.out.*" ]


def cbench_profile options
  valgrind = "valgrind --tool=callgrind --trace-children=yes"
  begin
    sh "#{ valgrind } #{ cbench_c_controller }"
    sh "#{ cbench_command } #{ options }"
  ensure
    sh "./trema killall"
  end
end


desc "Run the c cbench switch controller to benchmark"
task "cbench" => "cbench:c"


desc "Run the c cbench switch controller to benchmark"
task "cbench:c" => :default do | t |
  run_cbench cbench_c_controller
end


desc "Run the ruby cbench switch controller to benchmark"
task "cbench:ruby" => :default do | t |
  run_cbench cbench_ruby_controller
end


desc "Run cbench with profiling enabled."
task "cbench:profile" => :default do
  cbench_profile cbench_latency_mode_options
  cbench_profile cbench_throughput_mode_options
end


################################################################################
# Build vendor/*
################################################################################


task :vendor => [
  "vendor:openflow",
  "vendor:openvswitch",
  "vendor:oflops",
  "vendor:phost"
]


task "vendor:clean" => [
  "vendor:cmockery:clean",
  "vendor:oflops:clean",
  "vendor:openflow:clean",
  "vendor:openvswitch:clean",
  "vendor:phost:clean"
]


task "vendor:distclean" => [
  "vendor:cmockery:distclean",
  "vendor:oflops:distclean",
  "vendor:openflow:distclean",
  "vendor:openvswitch:distclean",
  "vendor:phost:distclean"
]


task :distclean => [
  "vendor:cmockery:distclean",
  "vendor:oflops:distclean",
  "vendor:openflow:distclean",
  "vendor:openvswitch:distclean",
  "vendor:phost:distclean"
]


#
# OpenFlow reference implementation
#


trema_directory Trema.objects


################################################################################
# Task vendor:openflow
################################################################################
task "vendor:openflow" => Trema.openflow_h
file Trema.openflow_h => Trema.objects do
  sh "tar -xzf #{ Trema.vendor_openflow }.tar.gz -C #{ Trema.vendor }"
  cp_r "#{ Trema.vendor_openflow }/include/openflow", Trema.objects
end

task "vendor:openflow:distclean" do
  rm_rf Trema.vendor_openflow
end


################################################################################
# Task unittests
################################################################################
def libtrema_unit_tests
  {
    :byteorder_test => [ :log, :utility, :wrapper, :trema_wrapper ],
    :daemon_test => [],
    :ether_test => [ :buffer, :log, :utility, :wrapper, :trema_wrapper ],
    :messenger_test => [ :doubly_linked_list, :hash_table, :event_handler, :linked_list, :utility, :wrapper, :timer, :log, :trema_wrapper ],
    :openflow_application_interface_test => [ :buffer, :byteorder, :hash_table, :doubly_linked_list, :linked_list, :log, :openflow_message, :packet_info, :stat, :trema_wrapper, :utility, :wrapper ],
    :openflow_message_test => [ :buffer, :byteorder, :linked_list, :log, :packet_info, :utility, :wrapper, :trema_wrapper ],
    :packet_info_test => [ :buffer, :log, :utility, :wrapper, :trema_wrapper ],
    :stat_test => [ :hash_table, :doubly_linked_list, :log, :utility, :wrapper, :trema_wrapper ],
    :timer_test => [ :log, :utility, :wrapper, :doubly_linked_list, :trema_wrapper ],
    :trema_test => [ :utility, :log, :wrapper, :doubly_linked_list, :trema_private, :trema_wrapper ],
  }
end


def test_object_files test
  names = [ test.to_s.gsub( /_test$/, "" ) ] + libtrema_unit_tests[ test ]
  names.collect do | each |
    if each == :buffer
      [ "unittests/objects/buffer.o", "unittests/objects/buffer_stubs.o" ]
    elsif each == :wrapper
      [ "unittests/objects/wrapper.o", "unittests/objects/wrapper_stubs.o" ]
    else
      "unittests/objects/#{ each }.o"
    end
  end.flatten
end


trema_directory "unittests/objects"
trema_directory "objects/unittests"


rule /unittests\/objects\/.*.o$/ => lambda { | fn | fn.sub( /unittests\/objects\/(.*).o$/ ) { | str | "unittests/lib/#{ $1 }.c" } } do | t |
  sh "gcc -I#{ Trema.include } -I#{ Trema.openflow } -I#{ File.dirname Trema.cmockery_h } -Iunittests -DUNIT_TESTING --coverage #{ CFLAGS } -c -o #{ t.name } #{ t.source }"
end


rule /unittests\/objects\/.*.o$/ => lambda { | fn | fn.sub( /unittests\/objects\/(.*).o$/ ) { | str | "unittests/#{ $1 }.c" } } do | t |
  sh "gcc -I#{ Trema.include } -I#{ Trema.openflow } -I#{ File.dirname Trema.cmockery_h } -Iunittests -DUNIT_TESTING --coverage #{ CFLAGS } -c -o #{ t.name } #{ t.source }"
end

rule /unittests\/objects\/.*.o$/ => lambda { | fn | fn.sub( /unittests\/objects\/(.*).o$/ ) { | str | "src/lib/#{ $1 }.c" } } do | t |
  sh "gcc -I#{ Trema.include } -I#{ Trema.openflow } -I#{ File.dirname Trema.cmockery_h } -Iunittests -DUNIT_TESTING --coverage #{ CFLAGS } -c -o #{ t.name } #{ t.source }"
end


libtrema_unit_tests.keys.each do | each |
  target = "unittests/objects/#{ each }"
  task :build_old_unittests => target
  task target => "vendor:cmockery"
  file target => test_object_files( each ) + [ "#{ target }.o" ] do | t |
    sh "gcc -L#{ File.dirname Trema.libcmockery_a } -o #{ t.name } #{ test_object_files( each ).join( ' ' ) } #{ target }.o -DUNIT_TESTING -lrt -lcmockery -lsqlite3 -ldl -lpthread --coverage --static"
  end
end


tests = [
  "objects/unittests/buffer_test",
  "objects/unittests/doubly_linked_list_test",
  "objects/unittests/ether_test",
  "objects/unittests/hash_table_test",
  "objects/unittests/linked_list_test",
  "objects/unittests/log_test",
  "objects/unittests/packetin_filter_interface_test",
  "objects/unittests/packet_info_test",
  "objects/unittests/packet_parser_test",
  "objects/unittests/persistent_storage_test",
  "objects/unittests/trema_private_test",
  "objects/unittests/utility_test",
  "objects/unittests/wrapper_test",
  "objects/unittests/match_table_test",
  "objects/unittests/message_queue_test",
]


file "objects/unittests/cmockery_trema.o" do | t |
  sh "gcc --coverage -c unittests/#{ File.basename t.name, ".o" }.c -o #{ t.name } #{ CFLAGS } -I#{ Trema.include } -I#{ File.dirname Trema.cmockery_h } -Iunittests"
end


tests.each do | each |
  task :build_unittests => [ "coverage:libtrema", each ]
  task each => [ "coverage:libtrema", "vendor:cmockery", "objects/unittests/cmockery_trema.o", "#{ Trema.home }/objects/unittests" ]
  file each => "unittests/lib/#{ File.basename each }.c" do | t |
    sh "gcc --coverage -c unittests/lib/#{ File.basename t.name }.c -o #{ each }.o #{ CFLAGS } -I#{ Trema.include } -I#{ Trema.openflow } -I#{ File.dirname Trema.cmockery_h } -Iunittests"
    sh "gcc --coverage -o #{ t.name } #{ each }.o objects/unittests/cmockery_trema.o -Lobjects/unittests -L#{ File.dirname Trema.libcmockery_a } -ltrema -lrt -lcmockery -lsqlite3 -ldl -lpthread --static"
  end
end


desc "Run unittests"
task :unittests => [ "vendor:openflow", :build_old_unittests, :build_unittests ] do
  ( FileList[ "unittests/objects/*_test" ] + tests ).each do | each |
    puts "Running #{ each }..."
    sh each
  end
end


################################################################################
# Task apps:topology_client
################################################################################
task :clean => "topology_client:clean"
task :distclean => "topology_client:distclean"


task "topology_client:clean" do
  cd "#{ Trema.topology }" do
    rm_f FileList[ "*.o", "*.a" ]
    rm_f [ "mkmf.log", "topology_client.so", "topology_client.map" ]
  end
end


task "topology_client:distclean" do
  cd "#{ Trema.topology }" do
    rm_f FileList[ "*~" ]
    rm_f [ "Makefile", "core" ]
  end
end


################################################################################
desc "Build topology client"
task :topology_client => [ "#{ Trema.topology }/topology_client.so" ]
file "#{ Trema.topology }/topology_client.so" do
  cd "#{ Trema.topology }" do
    sh "ruby extconf.rb --with-trema-include=#{ Trema.include } --with-topology-include=#{ Trema.topology } --with-routing-include=#{ Trema.routing_switch } --with-openflow-include=#{ Trema.openflow }"
    sh "make"
  end
end


################################################################################
# Task apps:path_resolver_client
################################################################################
task :clean => "path_resolver_client:clean"
task :distclean => "path_resolver_client:distclean"


task "path_resolver_client:clean" do
  cd "#{ Trema.path_resolver_client }" do
    rm_f FileList[ "*.o", "*.a" ]
    rm_f [ "mkmf.log", "path_resolver_client.so", "path_resolver_client.map" ]
  end
end


task "path_resolver_client:distclean" do
  cd "#{ Trema.path_resolver_client }" do
    rm_f FileList[ "*~" ]
    rm_f [ "Makefile", "core" ]
  end
end


################################################################################
desc "Build path resolver client"
task :path_resolver_client => [ "#{ Trema.path_resolver_client }/path_resolver_client.so" ]
file "#{ Trema.path_resolver_client }/path_resolver_client.so" do
  cd "#{ Trema.path_resolver_client }" do
    sh "ruby extconf.rb --with-trema-include=#{ Trema.include } --with-topology-include=#{ Trema.topology } --with-routing-include=#{ Trema.routing_switch } --with-openflow-include=#{ Trema.openflow }"
    sh "make"
  end
end


################################################################################
# Task apps:authenticator
################################################################################
task :clean => "authenticator:clean"
task :distclean => "authenticator:distclean"


task "authenticator:clean" do | t |
  cd "#{ Trema.redirectable_routing_switch }" do
    rm_f FileList[ "*authenticator*.o", "*authenticator*.a" ]
    rm_f [ "mkmf.log", "authenticator.so", "authenticator.map" ]
  end
end


task "authenticator:distclean" do
  cd "#{ Trema.redirectable_routing_switch }" do
    rm_f FileList[ "*~" ]
    rm_f [ "Makefile", "core" ]
  end
end


################################################################################
desc "Build authenticator"
task :authenticator => [ "#{ Trema.redirectable_routing_switch }/authenticator.so" ]
file "#{ Trema.redirectable_routing_switch }/authenticator.so" do
  cd "#{ Trema.redirectable_routing_switch }" do
    sh "ruby extconf.rb --with-trema-include=#{ Trema.include } --with-openflow-include=#{ Trema.openflow } --with-target-lib=authenticator"
    sh "make"
  end
end


################################################################################
# Task apps:redirector
################################################################################
task :clean => "redirector:clean"
task :distclean => "redirector:distclean"


task "redirector:clean" do
  cd "#{ Trema.redirectable_routing_switch }" do
    rm_f FileList[ "*redirector*.o", "*redirector*.a" ]
    rm_f [ "mkmf.log", "redirector.so", "redirector.map" ]
  end
end


task "redirector:distclean" do
  cd "#{ Trema.redirectable_routing_switch }" do
    rm_f FileList[ "*~" ]
    rm_f [ "Makefile", "core" ]
  end
end


desc "Build redirector"
task :redirector => [ "#{ Trema.redirectable_routing_switch }/redirector.so" ]
file "#{ Trema.redirectable_routing_switch }/redirector.so" do
  cd "#{ Trema.redirectable_routing_switch }" do
    sh "ruby extconf.rb --with-trema-include=#{ Trema.include } --with-trema-lib=#{ Trema.lib } --with-openflow-include=#{ Trema.openflow } --with-target-lib=redirector"
    sh "make"
  end
end


################################################################################
# Task apps:broadcast_helper
################################################################################
task :clean => "broadcast_helper:clean"
task :distclean => "broadcast_helper:distclean"


task "broadcast_helper:clean" do
  cd "#{ Trema.apps }/broadcast_helper" do
    rm_f FileList[ "*.o", "*.a" ]
    rm_f [ "broadcast_helper" ]
  end
end


task "broadcast_helper:distclean" do
  cd "#{ Trema.apps }/broadcast_helper" do
    rm_f FileList[ "*~" ]
    rm_f [ "Makefile", "core" ]
  end
end


desc "Build broadcast helper"
task :broadcast_helper => "#{ Trema.apps }/broadcast_helper/broadcast_helper"
broadcast_helper_src = FileList[ "#{ Trema.apps }/broadcast_helper/*.c" ]
broadcast_helper_objs = broadcast_helper_src.ext( 'o' )
rule /apps\/broadcast_helper.*.o$/  => lambda { | fn | fn.sub( /\.o$/, '.c') } do | t |
  sh "gcc -I#{ Trema.include } -I#{ Trema.openflow } -I#{ Trema.apps}/topology #{ CFLAGS } -fPIC -c -o #{ t.name } #{ t.source }"
end

file "#{ Trema.apps }/broadcast_helper/broadcast_helper" => broadcast_helper_objs do | t |
  sh "gcc -L#{ Trema.lib } -L#{ Trema.apps }/topology -o #{ t.name } #{ broadcast_helper_objs } -ltrema -ltopology -lsqlite3 -ldl -lrt -lpthread"
end


################################################################################
# Task apps:flow_dumper
################################################################################
task :clean => "flow_dumper:clean"
task :distclean => "flow_dumper:distclean"


task "flow_dumper:clean" do
  cd "#{ Trema.apps }/flow_dumper" do
    rm_f FileList[ "*.o", "*.a" ]
    rm_f [ "flow_dumper" ]
  end
end


task "flow_dumper:distclean" do
  cd "#{ Trema.apps }/flow_dumper" do
    rm_f FileList[ "*~" ]
    rm_f [ "Makefile", "core" ]
  end
end


desc "Build flow dumper"
task :flow_dumper => "#{ Trema.apps }/flow_dumper/flow_dumper"
flow_dumper_src = FileList[ "#{ Trema.apps }/flow_dumper/*.c" ]
flow_dumper_objs = flow_dumper_src.ext( 'o' )
rule /apps\/flow_dumper.*.o$/ => lambda { | fn | fn.sub( /\.o$/, '.c') } do | t |
  sh "gcc -I#{ Trema.include } -I#{ Trema.openflow } -I#{ Trema.apps }/topology #{ CFLAGS } -fPIC -c -o #{ t.name } #{ t.source }"
end
file "#{ Trema.apps }/flow_dumper/flow_dumper" => flow_dumper_objs do | t |
  sh "gcc -L#{ Trema.lib } -o #{ t.name } #{ flow_dumper_objs } -ltrema -lsqlite3 -ldl -lrt -lpthread"
end


################################################################################
# Task apps:flow_manager
################################################################################
task :clean => "flow_manager:clean"
task :distclean => "flow_manager:distclean"


task "flow_manager:clean" do
  cd "#{ Trema.apps }/flow_manager" do
    rm_f FileList[ "*.o", "*.a" ]
    rm_f [ "flow_manager" ]
    cd "examples" do
      rm_f FileList[ "*.o", "*.a" ]
      ( 1..5 ).each do | i |
        rm_f [ "example#{ i }" ]
      end
    end
  end
end


task "flow_manager:distclean" do
  cd "#{ Trema.apps }/flow_manager" do
    rm_f FileList[ "*~" ]
    rm_f [ "Makefile", "core" ]
    cd "examples" do
      rm_f [ "Makefile", "core" ]
    end
  end
end


desc "Build flow manager"
task :flow_manager => [ 
  "#{ Trema.apps }/flow_manager/flow_manager", 
  "#{ Trema.apps }/flow_manager/libpath.a",
  :flow_manager_examples
]
flow_manager_src = FileList[ "#{ Trema.apps }/flow_manager/flow_manager.c", "#{ Trema.apps }/flow_manager/flow_manager_interface.c" ]
flow_manager_objs = flow_manager_src.ext( 'o' )
rule /apps\/flow_manager.*.o$/ => lambda { | fn | fn.sub( /\.o$/, '.c') } do | t |
  sh "gcc -I#{ Trema.include } -I#{ Trema.openflow } -I#{ Trema.apps }/flow_manager #{ CFLAGS } -fPIC -c -o #{ t.name } #{ t.source }"
end
file "#{ Trema.apps }/flow_manager/flow_manager" => flow_manager_objs do | t |
  sh "gcc -L#{ Trema.lib } -o #{ t.name } #{ flow_manager_objs } -ltrema -lsqlite3 -ldl -lrt -lpthread"
end

libpath_src = FileList[ "#{ Trema.apps }/flow_manager/libpath.c", "#{ Trema.apps }/flow_manager/flow_manager_interface.c" ]
libpath_objs = libpath_src.ext( 'o' )
file "#{ Trema.apps }/flow_manager/libpath.a" => libpath_objs do | t |
  sh "ar -cq #{ t.name } #{ libpath_objs }"
  sh "ranlib #{ t.name }"
end


fm_examples = Array.new( 5 ) { | i | "#{ Trema.apps }/flow_manager/examples/example#{ i + 1 }" }
task :flow_manager_examples => fm_examples

fm_examples.each do | each |
  src = FileList[ "#{ Trema.apps }/flow_manager/examples/utils.c", "#{ each }.c" ]
  objs = src.ext( 'o' )

  file "#{ each }" => objs do | t |
    sh "gcc -L#{ Trema.lib } -L#{ Trema.apps }/flow_manager -o #{ t.name } #{ objs } -ltrema -lsqlite3 -ldl -lrt -lpthread -lpath"
  end
end


################################################################################
# Task apps:load_balance_switch
################################################################################
task :clean => "load_balance_switch:clean"
task :distclean => "load_balance_switch:distclean"


task "load_balance_switch:clean" do
  cd "#{ Trema.apps }/load_balance_switch" do
    rm_f FileList[ "*.o", "*.a" ]
    rm_f [ "switch" ]
  end
end


task "load_balance_switch:distclean" do
  cd "#{ Trema.apps }/load_balance_switch" do
    rm_f FileList[ "*~" ]
    rm_f [ "Makefile", "core" ]
  end
end


desc "Build load balance switch"
task :load_balance_switch => [ "#{ Trema.apps }/load_balance_switch/switch" ]

load_balance_switch_src = FileList[ "#{ Trema.apps }/load_balance_switch/*.c" ]
load_balance_switch_objs = load_balance_switch_src.ext( 'o' )
rule /apps\/load_balance_switch.*.o$/ => lambda { | fn | fn.sub( /\.o$/, '.c' ) } do | t |
  sh "gcc -I#{ Trema.include } -I#{ Trema.openflow } -I#{ Trema.topology } -I#{ Trema.apps }/path_manager #{ CFLAGS } -fPIC -c -o #{ t.name } #{ t.source }"
end
file "#{ Trema.apps }/load_balance_switch/switch" => load_balance_switch_objs do | t |
  sh "gcc -L#{ Trema.lib } -L#{ Trema.topology } -o #{ t.name } #{ load_balance_switch_objs } -ltrema -lsqlite3 -ldl -lrt -lpthread -ltopology"
end


################################################################################
# Task apps:packetin_dispatcher
################################################################################
task :clean => "packetin_dispatcher:clean"
task :distclean => "packetin_dispatcher:distclean"


task "packetin_dispatcher:clean" do
  cd "#{ Trema.apps }/packetin_dispatcher" do
    rm_f FileList[ "*.o", "*.a" ]
    rm_f [ "packetin_dispatcher" ]
  end
end


task "packetin_dispatcher:distclean" do
  cd "#{ Trema.apps }/packetin_dispatcher" do
    rm_f FileList[ "*~" ]
    rm_f [ "Makefile", "core" ]
  end
end


desc "Build packet-in dispatcher"
task :packetin_dispatcher => [ "#{ Trema.apps }/packetin_dispatcher/packetin_dispatcher" ]

packetin_dispatcher_src = FileList[ "#{ Trema.apps }/packetin_dispatcher/*.c" ]
packetin_dispatcher_objs = packetin_dispatcher_src.ext( 'o' )
rule /apps\/packetin_dispatcher.*.o$/ => lambda { | fn | fn.sub( /\.o$/, '.c' ) } do | t |
  sh "gcc -I#{ Trema.include } -I#{ Trema.openflow } -I#{ Trema.topology } #{ CFLAGS } -fPIC -c -o #{ t.name } #{ t.source }"
end
file "#{ Trema.apps }/packetin_dispatcher/packetin_dispatcher" => packetin_dispatcher_objs do | t |
  sh "gcc -L#{ Trema.lib } -o #{ t.name } #{ packetin_dispatcher_objs } -ltrema -lsqlite3 -ldl -lrt -lpthread"
end


################################################################################
# Task apps:path_manager
################################################################################
task :clean => "path_manager:clean"
task :distclean => "path_manager:distclean"


task "path_manager:clean" do
  cd "#{ Trema.apps }/path_manager" do
    rm_f FileList[ "*.o", "*.a" ]
    rm_f [ "path_manager" ]
  end
end


task "path_manager:distclean" do
  cd "#{ Trema.apps }/path_manager" do
    rm_f FileList[ "*~" ]
    rm_f [ "Makefile", "core" ]
  end
end

desc "Build path manager"
task :path_manager => [ "#{ Trema.apps }/path_manager/path_manager" ]

path_manager_src = FileList[ "#{ Trema.apps }/path_manager/*.c" ]
path_manager_objs = path_manager_src.ext( 'o' )
rule /apps\/path_manager.*.o$/ => lambda { | fn | fn.sub( /\.o$/, '.c' ) } do | t |
  sh "gcc -I#{ Trema.include } -I#{ Trema.openflow } #{ CFLAGS } -fPIC -c -o #{ t.name } #{ t.source }"
end
file "#{ Trema.apps }/path_manager/path_manager" => path_manager_objs do | t |
  sh "gcc -L#{ Trema.lib } -o #{ t.name } #{ path_manager_objs } -ltrema -lsqlite3 -ldl -lrt -lpthread"
end


################################################################################
# Task apps:routing_switch
################################################################################
task :clean => "routing_switch:clean"
task :distclean => "routing_switch:distclean"


task "routing_switch:clean" do
  cd "#{ Trema.apps }/routing_switch" do
    rm_f FileList[ "*.o", "*.a" ]
    rm_f [ "routing_switch" ]
  end
end


task "routing_switch:distclean" do
  cd "#{ Trema.apps }/routing_switch" do
    rm_f FileList[ "*~" ]
    rm_f [ "Makefile", "core" ]
  end
end


desc "Build routing switch"
task :routing_switch => [ "#{ Trema.apps }/routing_switch/routing_switch" ]

routing_switch_src = FileList[ 
  "#{ Trema.apps }/routing_switch/fdb.c",
  "#{ Trema.apps }/routing_switch/libpathresolver.c",
  "#{ Trema.apps }/routing_switch/port.c",
  "#{ Trema.apps }/routing_switch/routing_switch.c"
]
routing_switch_objs = routing_switch_src.ext( 'o' )
rule /apps\/routing_switch.*.o$/ => lambda { | fn | fn.sub( /\.o$/, '.c' ) } do | t |
  sh "gcc -I#{ Trema.include } -I#{ Trema.openflow } -I#{ Trema.topology} #{ CFLAGS } -fPIC -c -o #{ t.name } #{ t.source }"
end
file "#{ Trema.apps }/routing_switch/routing_switch" => routing_switch_objs do | t |
  sh "gcc -L#{ Trema.lib } -L#{ Trema.topology } -o #{ t.name } #{ routing_switch_objs } -ltrema -lsqlite3 -ldl -lrt -lpthread -ltopology"
end


targets = [ "show_description", "simple_load_balancer" ]

targets.each do | target |
  target_name = target_dir = target
  task :clean => "#{ target_name }:clean"
  task :distclean => "#{ target_name }:distclean"

  task "#{ target_name }:clean" do
    cd "#{ Trema.apps }/#{ target_dir }" do
      rm_f FileList[ "*.o", "*.a" ]
      rm_f [ "#{ target_name }" ]
    end
  end

  task "#{ target_name }:distclean" do
    cd "#{ Trema.apps }/#{ target_dir }" do
      rm_f FileList[ "*~" ]
      rm_f [ "Makefile", "core" ]
    end
  end

  desc "Build #{ target_name }"
  task :"#{ target_name }" => [ "#{ Trema.apps }/#{ target_dir }/#{ target_name }" ]

  target_src = FileList[ "#{ Trema.apps }/#{ target_dir }/*.c" ]
  target_objs = target_src.ext( 'o' )
  rule /apps\/#{ target_dir }.*.o$/ => lambda { | fn | fn.sub( /\.o$/, '.c' ) } do | t |
    sh "gcc -I#{ Trema.include } -I#{ Trema.openflow } #{ CFLAGS } -fPIC -c -o #{ t.name } #{ t.source }"
  end
  file "#{ Trema.apps }/#{ target_dir }/#{ target_name }" => target_objs do | t |
    sh "gcc -L#{ Trema.lib } -o #{ t.name } #{ target_objs } -ltrema -lsqlite3 -ldl -lrt -lpthread"
  end
end


################################################################################
# Task apps:sliceable_switch
################################################################################
task :clean => "sliceable_switch:clean"
task :distclean => "sliceable_switch:distclean"


task "sliceable_switch:clean" do
  cd "#{ Trema.apps }/sliceable_switch" do
    rm_f FileList[ "*.o", "*.a" ]
    rm_f [ "sliceable_switch" ]
  end
end


task "sliceable_switch:distclean" do
  cd "#{ Trema.apps }/sliceable_switch" do
    rm_f FileList[ "*~" ]
    rm_f [ "Makefile", "core" ]
  end
end


desc "Build sliceble_switch"
task :sliceable_switch => [ "#{ Trema.apps }/sliceable_switch/sliceable_switch" ]

sliceable_switch_src = FileList[ 
  "#{ Trema.apps }/sliceable_switch/fdb.c",
  "#{ Trema.apps }/sliceable_switch/filter.c",
  "#{ Trema.apps }/sliceable_switch/libpathresolver.c",
  "#{ Trema.apps }/sliceable_switch/port.c",
  "#{ Trema.apps }/sliceable_switch/sliceable_switch.c",
  "#{ Trema.apps }/sliceable_switch/slice.c",
  "#{ Trema.apps }/sliceable_switch/redirector.c"
]
sliceable_switch_objs = sliceable_switch_src.ext( 'o' )
rule /apps\/sliceable_switch\/.*.o$/ => lambda { | fn | fn.sub( /\.o$/, '.c' ) } do | t |
  sh "gcc -I#{ Trema.include } -I#{ Trema.openflow } -I#{ Trema.topology } -I#{ Trema.apps }/flow_manager #{ CFLAGS } -fPIC -c -o #{ t.name } #{ t.source }"
end
file "#{ Trema.apps }/sliceable_switch/sliceable_switch" => sliceable_switch_objs do | t |
  sh "gcc -L#{ Trema.lib } -L#{ Trema.topology } -L#{ Trema.apps }/flow_manager -o #{ t.name } #{ sliceable_switch_objs } -ltrema -lsqlite3 -ldl -lrt -lpthread -ltopology -lpath"
end


################################################################################
# Task apps:topology
################################################################################
desc "Build topology"
task :topology => [ 
  "#{ Trema.apps }/topology/libtopology.a",
  "#{ Trema.apps }/topology/topology", 
  "#{ Trema.apps }/topology/topology_discovery", 
  "#{ Trema.apps }/topology/show_topology"
]
libtopology_src = FileList[ 
  "#{ Trema.apps }/topology/libtopology.c",
  "#{ Trema.apps }/topology/topology_service_interface_option_parser.c"
]
libtopology_objs = libtopology_src.ext( 'o' )

topology_src = FileList[ 
  "#{ Trema.apps }/topology/service_management.c", 
  "#{ Trema.apps }/topology/subscriber_table.c",
  "#{ Trema.apps }/topology/topology.c",
  "#{ Trema.apps }/topology/topology_management.c",
  "#{ Trema.apps }/topology/topology_table.c" 
]
topology_objs = topology_src.ext( 'o' )


topology_discovery_src = FileList[ 
  "#{ Trema.apps }/topology/lldp.c", 
  "#{ Trema.apps }/topology/probe_timer_table.c", 
  "#{ Trema.apps }/topology/topology_discovery.c" 
]
topology_discovery_objs = topology_discovery_src.ext( 'o' )


show_topology_src = FileList[
  "#{ Trema.apps }/topology/show_topology.c", 
  "#{ Trema.apps }/topology/show_topology_dsl.c", 
  "#{ Trema.apps }/topology/show_topology_graph_easy.c", 
  "#{ Trema.apps }/topology/show_topology_csv.c"
]
show_topology_objs = show_topology_src.ext( 'o' )


rule /topology\/.*.o$/ => lambda { | fn | fn.sub( /\.o$/, '.c') } do | t |
  sh "gcc -I#{ Trema.include } -I#{ Trema.openflow } #{ CFLAGS } -fPIC -c -o #{ t.name } #{ t.source }"
end


file "#{ Trema.apps }/topology/libtopology.a" => libtopology_objs do | t |
  sh "ar -cq #{ t.name } #{ libtopology_objs }"
  sh "ranlib #{ t.name }"
end

file "#{ Trema.apps }/topology/topology" => topology_objs do | t |
  sh "gcc -L#{ Trema.lib } -o #{ t.name } #{ topology_objs } -ltrema -lsqlite3 -ldl -lrt -lpthread"
end

file "#{ Trema.apps }/topology/topology_discovery" => topology_discovery_objs do | t |
  sh "gcc -L#{ Trema.lib } -L#{ Trema.apps }/topology -o #{ t.name } #{ topology_discovery_objs } -ltrema -lsqlite3 -ldl -lrt -lpthread -ltopology"
end

file "#{ Trema.apps }/topology/show_topology" => show_topology_objs do | t |
  sh "gcc -L#{ Trema.lib } -L#{ Trema.apps }/topology -o #{ t.name } #{ topology_discovery_objs } -ltrema -lsqlite3 -ldl -lrt -lpthread -ltopology"
end


################################################################################
# TODO, FIXME etc.
################################################################################
desc "Print list of notes."
task :notes do
  keywords = [ "TODO", "FIXME", "XXX" ]
  keywords.each do | key |
    sh "find src unittests -name '*.c' | xargs grep -n #{ key }" rescue nil
    sh "find ruby spec features -name '*.rb' | xargs grep -n #{ key }" rescue nil
  end
end


### Local variables:
### mode: Ruby
### coding: utf-8-unix
### indent-tabs-mode: nil
### End:
